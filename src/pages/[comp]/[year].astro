---
import Base from "../../layouts/Base.astro";
import { listEditionParams, getEditionTable, getJudgeScoreTable, listEditionYears } from "../../lib/queries";
import JudgeScoresTable from "../../components/JudgeScoresTable.astro";

const base = import.meta.env.BASE_URL;

export async function getStaticPaths() {
  const params = listEditionParams()
    .filter(p => p.year != null)
    .map(p => ({ params: { comp: p.comp, year: String(p.year) } }));

  return params;
}

const { comp, year } = Astro.params as { comp: string; year: string };
const y = Number(year);
const data = getEditionTable(comp, y);
if (!data) throw new Error("該当データなし");
const { edition, rows, columns } = data;

// タイトルは edition.title があれば優先、無ければ従来の "{competition_name} {year} 決勝結果"
const pageTitle = edition.title ?? `${edition.competition_name} ${edition.year} 決勝結果`;

// "YYYY-MM-DD" → "YYYY年M月D日(曜)" 変換（final_date があれば表示）
function formatJpDate(s?: string | null) {
  if (!s) return null;
  // "YYYY-M-D" or "YYYY-MM-DD" を許容して手動パース
  const m = String(s).trim().match(/^(\d{4})-(\d{1,2})-(\d{1,2})$/);
  if (!m) return s; // 期待フォーマットでない場合は原文返し
  const y = Number(m[1]), mo = Number(m[2]), d = Number(m[3]);
  // UTC基準で曜日を出す（ローカルTZのズレ防止）
  const dt = new Date(Date.UTC(y, mo - 1, d));
  const youbi = ["日","月","火","水","木","金","土"][dt.getUTCDay()];
  return `${y}年${mo}月${d}日(${youbi})`;
}

const finalDateText = formatJpDate(edition.final_date);

// 表示する列（DBメタ順）
const cols = columns; // [{key,label,col_class,is_multiline,related_key}, ...]

const round1 = getJudgeScoreTable(comp, y, 1);
const round2 = getJudgeScoreTable(comp, y, 2);

/** 両ラウンド合算で各席の min/max→mid/half を作り、最大 half を globalHalf に */
function buildSharedScale(r1: typeof round1, r2: typeof round2){
  const bySeat: Record<number, { mid:number; half:number }> = {};
  let globalHalf = 0;

  // 座席リスト（通常は同じだが、念のためユニオン）
  const seatNos = new Set<number>();
  for (const s of (r1?.seats ?? [])) seatNos.add(s.seat_no);
  for (const s of (r2?.seats ?? [])) seatNos.add(s.seat_no);

  for (const seat of seatNos) {
    let min = +Infinity, max = -Infinity;
    for (const tbl of [r1, r2]) {
      if (!tbl) continue;
      for (const row of tbl.rows) {
        const v = row.bySeat[seat];
        if (typeof v === "number" && !Number.isNaN(v)) {
          if (v < min) min = v;
          if (v > max) max = v;
        }
      }
    }
    if (min === +Infinity) { min = 0; max = 0; }
    const mid  = (min + max) / 2;
    const half = Math.max(0, (max - min) / 2);
    bySeat[seat] = { mid, half };
    if (half > globalHalf) globalHalf = half;
  }
  if (globalHalf === 0) globalHalf = 1;

  // 合計列のスケール（両ラウンド合算）
  let tmin = +Infinity, tmax = -Infinity;
  for (const tbl of [r1, r2]) {
    if (!tbl) continue;
    for (const row of tbl.rows) {
      const v = row.total;
      if (typeof v === "number" && !Number.isNaN(v)) {
        if (v < tmin) tmin = v;
        if (v > tmax) tmax = v;
      }
    }
  }
  const total = (tmin===+Infinity)
    ? { mid: 0, half: 1 }
    : { mid: (tmin + tmax)/2, half: Math.max(1e-9, (tmax - tmin)/2) };
  return { bySeat, globalHalf, total };
}

const sharedScale = buildSharedScale(round1, round2);

// 前年・翌年を特定
const years = listEditionYears(comp);                // 昇順
const i = years.indexOf(y);
const prevYear = i > 0 ? years[i-1] : null;          // 前年（存在すれば）
const nextYear = i >= 0 && i < years.length-1 ? years[i+1] : null; // 翌年
---
<Base title={`${pageTitle} 決勝結果`}>
  <nav class="breadcrumbs">
    <a href={base}>トップ</a><span class="sep">/</span>
    <a href={`${base}${comp}`}>{edition.competition_name}</a><span class="sep">/</span>
    <span>{edition.year}年</span>
  </nav>

  <div class="sticky-h1">
    <div class="h1-row">
      <h1>{pageTitle} 決勝結果</h1>
      {(prevYear != null || nextYear != null) && (
        <nav class="year-pager">
          {prevYear != null && (
            <a class="btn" href={`${base}${comp}/${prevYear}`} aria-label={`${prevYear}年へ`}>← {prevYear}</a>
          )}
          {nextYear != null && (
            <a class="btn" href={`${base}${comp}/${nextYear}`} aria-label={`${nextYear}年へ`}>{nextYear} →</a>
          )}
        </nav>
      )}
    </div>
  </div>
  <!-- <div>
    {finalDateText && <p class="muted h1-sub">決勝: {finalDateText}</p>}
  </div> -->

  <div class="table-wrap">
    <table>
      <thead>
        <tr>
          <th class="sticky-1 col-name">芸人</th>
          <th class="sticky-2 col-rank">順位</th>
          {cols.map((c:any) => <th class={c.col_class ?? ""}>{c.label ?? c.key}</th>)}
        </tr>
      </thead>
      <tbody>
        {rows.map(r => (
          <tr>
            <td class="sticky-1 col-name"><a href={`${base}co/${r.comedian_id}`}>{r.name}</a></td>
            <td class="sticky-2 col-rank">
              <span class="badge" data-ranksort={r.rank_sort}>{r.rank}</span>
            </td>
            {cols.map((c:any) => {
              const v = r[c.key];
              const text = v == null ? "" : String(v);
              const cls  = [c.col_class ?? "", c.is_multiline === 1 ? "multiline" : ""].filter(Boolean).join(" ");
              if (c.related_key) {
                const url = r[c.related_key] ? String(r[c.related_key]) : "";
                const isYouTube = !!url && /(?:^https?:\/\/)?(?:www\.)?(?:youtube\.com|youtu\.be)\//i.test(url);
                return (
                  <td class={cls}>
                    {text}
                    {url && " "}
                    {url && (
                      <a class={`video-link ${isYouTube ? "video-youtube" : ""}`}
                         href={url} target="_blank" rel="noopener noreferrer"
                         aria-label={isYouTube ? "YouTubeで見る" : "動画を見る"}>
                        <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                          <path fill="currentColor"
                            d="M23.5 6.2a4 4 0 0 0-2.8-2.8C18.5 3 12 3 12 3S5.5 3 3.3 3.4A4 4 0 0 0 .5 6.2 41 41 0 0 0 0 12c0 2 .2 3.8.5 5.8a4 4 0 0 0 2.8 2.8C5.5 21 12 21 12 21s6.5 0 8.7-.4a4 4 0 0 0 2.8-2.8c.3-2 .5-3.8.5-5.8s-.2-3.8-.5-5.8ZM9.75 15.02V8.98L15.5 12l-5.75 3.02Z"/>
                        </svg>
                      </a>
                    )}
                  </td>
                );
              }
              return <td class={cls}>{text}</td>;
            })}
          </tr>
        ))}
      </tbody>
    </table>
  </div>

  <JudgeScoresTable base={base} title="1本目 審査員別得点" table={round1} scale={sharedScale} />
  <JudgeScoresTable base={base} title="2本目 審査員別得点" table={round2} scale={sharedScale} />

  <p class="muted"><a href={`${base}${comp}`}>← {edition.competition_name} 年別一覧</a> / <a href={base}>トップ</a></p>
</Base>

<style is:inline>
  /* [comp]/[year] 用：h1 をヘッダーの下に固定 */
  .sticky-h1{
    position: sticky;
    top: calc(var(--header-h) + var(--header-gap)); /* 固定ヘッダー分ずらす */
    z-index: 10;          /* テーブル見出し(th: z-index:1)より上に */
    background: var(--bg);
    border-bottom: 1px solid var(--border);
    padding: 16px 0;
    /* iOS Safari 対策（ほぼ不要だが保険） */
    position: -webkit-sticky;
  }

  /* もし h1 が大きすぎて詰まるなら微調整可 */
  .sticky-h1 h1{
    margin: 0;            /* 余白で跳ねないように */
    line-height: 1.3;
  }

  .h1-row{ display:flex; align-items:baseline; gap:12px; flex-wrap:wrap; }
  .h1-sub{ margin:0; font-size:14px; }
</style>
