---
import Base from "../../layouts/Base.astro";
import { listComediansAll } from "../../lib/queries";

const base = import.meta.env.BASE_URL;

// かなユーティリティ（ページ内に最小実装）
const canon = (s: string) => s.normalize("NFKC").trim().replace(/\s+/g, " ");
const toHiragana = (s: string) => s.replace(/[\u30A1-\u30F6]/g, ch => String.fromCharCode(ch.charCodeAt(0) - 0x60));
const isKanaOnly = (s: string) => /^[\p{sc=Hiragana}\p{sc=Katakana}ー・･・\s]+$/u.test(canon(s));
const stripSymbolsForReading = (s: string) =>
  s.replace(/[・･·\u30FB\uFF65]/g, "")         // 中黒類
   .replace(/[\u0020\u00A0\u3000]/g, "")       // 空白
   .replace(/[()\[\]{}「」『』【】〈〉《》]/g, "") // 括弧
   .replace(/[.,，．\/／]/g, "")               // 句読点など
   .replace(/[-_—–―]/g, "");                   // ハイフン類（長音ーは残す）

// 読みの決定（DBのreading優先。無ければ名前がかなのみなら推測）
const decideReading = (name: string, reading: string | null) => {
  if (reading && reading.trim() !== "") return reading;
  if (isKanaOnly(name)) return stripSymbolsForReading(toHiragana(canon(name)));
  return ""; // 推測不能
};

// 行グルーピング
const groups = [
  { key: "あ", set: "あいうえお" },
  { key: "か", set: "かきくけこがぎぐげご" },
  { key: "さ", set: "さしすせそざじずぜぞ" },
  { key: "た", set: "たちつてとだぢづでど" },
  { key: "な", set: "なにぬねの" },
  { key: "は", set: "はひふへほばびぶべぼぱぴぷぺぽ" },
  { key: "ま", set: "まみむめも" },
  { key: "や", set: "やゆよ" },
  { key: "ら", set: "らりるれろ" },
  { key: "わ", set: "わゐゑをん" }, // ん はここへ寄せる
];
const groupIndex = (ch: string) => {
  const h = toHiragana(ch);
  for (let i = 0; i < groups.length; i++) {
    if (groups[i].set.includes(h)) return i;
  }
  return -1; // その他
};

const raw = listComediansAll();

// 1) 読みを付与
const enriched = raw.map(r => {
  const reading = decideReading(r.name, r.reading);
  return { ...r, reading };
});

// 2) 読み→ソートキー（ひらがな前提）
const sortKey = (s: string, fallback: string) => (s && s.length ? s : fallback);

// 3) 行ごとにグルーピング
type Item = { id: string; name: string; reading: string };
const buckets: Record<string, Item[]> = {};
for (const g of groups) buckets[g.key] = [];
buckets["その他"] = [];

for (const r of enriched) {
  const rd = r.reading;
  const head = rd ? rd[0] : "";
  const idx = head ? groupIndex(head) : -1;
  const key = idx >= 0 ? groups[idx].key : "その他";
  buckets[key].push({ id: r.id, name: r.name, reading: rd });
}

// 4) 各バケット内を読み→名前でソート
const collator = new Intl.Collator("ja", { sensitivity: "base", usage: "sort" });
for (const k of Object.keys(buckets)) {
  buckets[k].sort((a, b) => {
    const ak = sortKey(a.reading, a.name);
    const bk = sortKey(b.reading, b.name);
    const c = collator.compare(ak, bk);
    if (c !== 0) return c;
    return collator.compare(a.name, b.name);
  });
}
---
<Base title="芸人一覧（五十音）">
  <nav class="breadcrumbs">
    <a href={base}>トップ</a><span class="sep">/</span>
    <span>芸人一覧</span>
  </nav>

  <h1>芸人一覧</h1>

  {groups.map(g => (
    <section>
      <h2>{g.key}行</h2>
      {buckets[g.key].length
        ? <p class="name-line">
            {buckets[g.key].map((it, i) => (
              <>
                {i > 0 && " / "}
                <a href={`${base}co/${it.id}`}>{it.name}</a>
              </>
            ))}
          </p>
        : <p class="muted">該当なし</p>}
    </section>
  ))}

  {/* その他グループ（ラテン文字・漢字のみ等） */}
  {buckets["その他"].length > 0 && (
    <section>
      <h2>その他</h2>
      <p class="name-line">
        {buckets["その他"].map((it, i) => (
          <>
            {i > 0 && " / "}
            <a href={`${base}co/${it.id}`}>{it.name}</a>
          </>
        ))}
      </p>
    </section>
  )}
</Base>

<style>
  .name-line { line-height: 1.9; }
  .name-line a { white-space: nowrap; }
</style>
