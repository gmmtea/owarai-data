---
import Base from "../../layouts/Base.astro";
import { listTargetComedianIds, getComedianTables } from "../../lib/queries";
import { orderColumns, labelFor, MULTILINE_KEYS, normalizeCellValue, relatedMovieKeyForTitle, isTitleKey, colClassFor } from "../../lib/columns";

const base = import.meta.env.BASE_URL;

export async function getStaticPaths() {
  const ids = listTargetComedianIds(); // string[]
  return ids.map((id) => ({ params: { id } }));
}

const { id } = Astro.params as { id: string };
const data = getComedianTables(id);
if (!data) throw new Error("該当データなし");
const { comedian, byComp } = data;
---
<Base title={`${comedian.name} の戦績`}>
  <nav class="breadcrumbs">
    <a href={base}>トップ</a><span class="sep">/</span>
    <a href={`${base}co`}>芸人一覧</a><span class="sep">/</span>
    <span>{comedian.name}</span>
  </nav>

  <h1>{comedian.name} の戦績</h1>
  <!-- <h1>
    <ruby>
      {comedian.name}
      {comedian.reading && <rt>{comedian.reading}</rt>}
    </ruby>
    の戦績
  </h1> -->
  {comedian.reading && (
    <p class="reading muted">{comedian.reading}</p>
  )}

  {Object.entries(byComp).map(([comp, block]: any) => {
    const cols = orderColumns(block.extraKeys);
    return (
      <section>
        <h2>{block.competition_name}</h2>
        <div class="table-wrap">
          <table>
            <thead>
              <tr>
                <th class="sticky-1 col-year">年</th>
                <th class="col-rank">順位</th>
                {cols.map((k: string) => <th class={colClassFor(k)}>{labelFor(k)}</th>)}
              </tr>
            </thead>
            <tbody>
              {block.rows.map((r: any) => (
                <tr>
                  <td class="sticky-1 col-year"><a href={`${base}${comp}/${r.year}`}>{r.year}</a></td>
                  <td class="col-rank"><span class="badge" data-ranksort={r.rank_sort}>{r.rank}</span></td>
                  {cols.map((k) => {
                    const text = normalizeCellValue(k, r[k]);
                    const cls  = [colClassFor(k), MULTILINE_KEYS.has(k) ? "multiline" : ""].filter(Boolean).join(" ");

                    if (isTitleKey(k)) {
                      // 対応する _movie を探す
                      const movieKey = relatedMovieKeyForTitle(k);
                      const url = movieKey ? normalizeCellValue(movieKey, r[movieKey]) : "";
                      const isYouTube = !!url && /(?:^https?:\/\/)?(?:www\.)?(?:youtube\.com|youtu\.be)\//i.test(url);
                      return (
                        <td class={cls}>
                          {text}
                          {url && " "}
                          {url && (
                            <a class={`video-link ${isYouTube ? "video-youtube" : ""}`}
                               href={url} target="_blank" rel="noopener noreferrer"
                               aria-label={isYouTube ? "YouTubeで見る" : "動画を見る"}>
                              <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                                <path fill="currentColor"
                                  d="M23.5 6.2a4 4 0 0 0-2.8-2.8C18.5 3 12 3 12 3S5.5 3 3.3 3.4A4 4 0 0 0 .5 6.2 41 41 0 0 0 0 12c0 2 .2 3.8.5 5.8a4 4 0 0 0 2.8 2.8C5.5 21 12 21 12 21s6.5 0 8.7-.4a4 4 0 0 0 2.8-2.8c.3-2 .5-3.8.5-5.8s-.2-3.8-.5-5.8ZM9.75 15.02V8.98L15.5 12l-5.75 3.02Z"/>
                              </svg>
                            </a>
                          )}
                        </td>
                      );
                    }
                    // 通常セル
                    return <td class={cls}>{text}</td>;
                  })}
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </section>
    );
  })}
</Base>
